### p的指向性问题
``` js
function serObj(p){
    p.name="小红";
    p={};
    p.name="西西"
}
var p={
    name:"小明"
}
setObj(p); //小红
console.log(p);
```
**解析**
``` js
function serObj(p){
    p.name="小红"; //通过p找到小明，
    //--将原来的小明改名为小红
    p={};//创建新对象开辟了一个新的内存
    //--至此局部变量p和外面存"小明"的
    //--那块内存没关系了
    p.name="西西"
}
var p={
    name:"小明"
}
setObj(p); //小红
console.log(p);
```

#### call函数的应用
涉及到函数调用时，里面的this不是我们想要的
怎么办
``` js
function calc(baase,bonus1,bonus2){
    ${this.ename}的总工资是
    ${base+bonus1+bonsu2}
}
```
var lilei={ename:"Li Lei"}
>lilei 不可能直接调用call ,calc
就不能直接调用lilei的参数，这时候就可
以用call来
`calc.call(hmm,4000,5000,6000);`

#### every回调函数的使用过程
``` js
 arr1=[1,2,3,4,5]
 arr2=[2,4,6,4,2]
 arr2.erery(function(elem,i,arr)){
     return elem%2==0;
 } //此every中elem为对应元素，i为元素对应索引值
 //此函数可以验证数组中的元素是否都为偶数
 ```

 #### forEach
 ``` js
  arr1=[1,2,3,4,5]
  arr1.forEach(function(elem,i,arr)){
      arri[i]=arr[i]*2//这样子的话，原数组就会
      //被更改
      //elem=arr[i]*2//这样就会复制副本之后
      //在更改，不会影响原来的的数组
  }

  var emps=[
      {eid:1,ename:"liang",salary:12000},
      {eid:2，enamel:"ran",salary:16000}，
      {eid:3，ename:"dong",salary:1800}
  ];
  emps.forEach(function(elem){
      //elem虽然发生了复制，但是复制的是地址，
      //用地址操作对象相当于操作了源对象，跟改了
      //原的对象
      elem.salary+=2000;
  })
  console.log(emps);
  ```

#### map 函数
``` js
arr =[1,2,3,4,5]
var lis= arr.map(function(elem){
    return `<li>${elem}</li>`
})
console.log(arr);
console.log(lis);
```
#### filter函数
``` js
<script>
var arr=[1,2,3,4,5];
var evens=arr.filter(
//先创建空数组等着接符合条件的元素
//var subArr=[]
//filter会拿着回调函数去每个元素上判断一次
  function(elem){
    //只要当前元素是偶数
    return elem%2==0//就放入新数组
  }
//如果当前元素判断结果为true，就追加到新数组
//if(return true) subArr.push(elem)
//遍历结束，返回subArr
)
console.log(arr);
console.log(evens);
</script>
 ```

 #### reduce 函数
 ``` js
 <script>
var class1=[1,3,5,7,9];
var result=class1.reduce(
  function(prev,elem){
    return prev+elem;//将当前值汇总到临时汇总值中
  },
  0//从0开始累加
);
var class2=[2,4,6,8,10];
result=class2.reduce(
  (prev,elem)=>prev+elem,
  result//从上一个班捐的总数继续开始累加
);
console.log(result);//25+30=55
</script>
 ```


 ### let 函数
 ``` js
 function fun(){
  var arr=[];//let将for变为块级作用域之后，
  //for内的变量在for外，不能使用。要想使用，
  //必须定义在for外部。
  //for(var i=0;i<3;i++){
  for(let i=0;i<3;i++){
    arr[i]=function(){console.log(i)}
  //(function(_i){
    //arr[_i]=function(){console.log(_i)}
  //})(i)
  }
  return arr;
}
var funs=fun();
funs[0]();//3  0
funs[1]();//3  1
funs[2]();//3  2
</script>
 ```
 #### 1.申明提前问题
```js
unction fun(){ console.log(1);}
fun();
function fun (){console.log(2);}
fun();
var fun=100;
fun();
```
**分析**
``` js
function fun(){ console.log(1);}//打酱油
fun(); //2
function fun (){console.log(2);}
//近似相当于var fun=function(){...}
fun();//2
var fun=100;
fun();  // 报错，fun现在由数字取代函数了，这么写报错
//遇到声明提前先提前 在分析，函数名fun只是个变量，
//函数就是个对象
```

### 数据类型
``` js
console.log(
  typeof 1,
  typeof "hello",
  typeof true,
  typeof null,
  typeof undefined,
  typeof function（）{}，
  typeof {sname:"Li Lei"},
  typeof [1,2,3],
  typeof NaN
);
```
######如何正确判断null和undefined*
```js
var obj=undefined;//null
//undefined在底层会被自动转换成null
console.log(obj===null);
//屏蔽了类型转换的可能
var a=0;
console.log(a=="");//true
console.log(a==="");//false
```
```js
var a=false;
console.log(a==="");//false
console.log(a==="");//false
//总结：今后判断null,undefined,0,"",false都要用===
//同理：!==（不全等于号）是屏蔽了自动顶
```
######如何判断正确判断NaN---isNaN()
``` js
var a=10, b=NaN,c="",d=false;
console.log(isNaN(a))//false
console.log(isNaN(b))//true
console.log(b=NaN)//false,也是一个判断方法
console.log(isNaN(c))//false
console.log(isNaN(d))//false
```
######如何判断数组和对象
``` js
var a={}, b=[],c=new Date(); 
console.log(//ES5
  Array.isArray(a),
  Array.isArray(b),
);
console.log(
  //toString()可输出一个对象内部属性class，
  //查看对象的类型名call()可强行让ab有这个查询方法
  Object.prototype.toString.call(a)===
  "[object object]",//true
  {}.toString.call(b)==="[object Array]"//更加高级
  object.prototype.toString.call(b)===
  "[object Array]"//true
);
```

### 字符串操作
######统计一个字符串中字符出现最多的字符
``` js
var str="helloworld";
//先定义空对象
var dict={};
//遍历字符串中的米格字母
for (var i=0;i<str.length;i++){
  if(dict[str[i]])===undefined{
    dict[str[i]]=1;//以前没见过就赋1
  }else{
    sict[str[i]]+=1;//以前见过就累加一个1
  }
}
console.log(dict)
var max,count=0;
for (var key of dict){
    if(dict[key]>count){
    max=key;
    count=dict[key]
    }
}
```
######数组去重
``` js
var arr==[1,2,3,4,3,2];//不许用API
//用字典，不许出现 重复的下标,出现自动覆盖
var dict={};
for(var i=0;i<arr.length;i++){
  dict[arr[i]]=1;
}
//遍历字典，值保留属性名
var result=[],i=0;
for (result[i++] in dict);//for...in遍历数组
//in 是依次取出属性名，并保存在result中
console.log(result);
```

### this指向性问题
``` js
var a=10 ;
var obj ={
  a:20,
  intr:function(){
    var a=30;
    console.log(this.a)
  }
}
obj.intr();//20
var intr=obj.intr;
intr();//10,intr变成最普通的函数了
```
``` js
var funx=[
  
];
for (var i=0;i<arr.length;i++){
  funs[i]=(function(i){
    return function(){
      console.log(i)
    }
  })(i);
}
funs[0]();
funs[1]();
funs[2]();
