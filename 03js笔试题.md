### p的指向性问题
``` js
function serObj(p){
    p.name="小红";
    p={};
    p.name="西西"
}
var p={
    name:"小明"
}
setObj(p); //小红
console.log(p);
```
**解析**
``` js
function serObj(p){
    p.name="小红"; //通过p找到小明，
    //--将原来的小明改名为小红
    p={};//创建新对象开辟了一个新的内存
    //--至此局部变量p和外面存"小明"的
    //--那块内存没关系了
    p.name="西西"
}
var p={
    name:"小明"
}
setObj(p); //小红
console.log(p);
```

#### call函数的应用
涉及到函数调用时，里面的this不是我们想要的
怎么办
``` js
function calc(baase,bonus1,bonus2){
    ${this.ename}的总工资是
    ${base+bonus1+bonsu2}
}
```
var lilei={ename:"Li Lei"}
>lilei 不可能直接调用call ,calc
就不能直接调用lilei的参数，这时候就可
以用call来
`calc.call(hmm,4000,5000,6000);`

#### every回调函数的使用过程
``` js
 arr1=[1,2,3,4,5]
 arr2=[2,4,6,4,2]
 arr2.erery(function(elem,i,arr)){
     return elem%2==0;
 } //此every中elem为对应元素，i为元素对应索引值
 //此函数可以验证数组中的元素是否都为偶数
 ```

 #### forEach
 ``` js
  arr1=[1,2,3,4,5]
  arr1.forEach(function(elem,i,arr)){
      arri[i]=arr[i]*2//这样子的话，原数组就会
      //被更改
      //elem=arr[i]*2//这样就会复制副本之后
      //在更改，不会影响原来的的数组
  }

  var emps=[
      {eid:1,ename:"liang",salary:12000},
      {eid:2，enamel:"ran",salary:16000}，
      {eid:3，ename:"dong",salary:1800}
  ];
  emps.forEach(function(elem){
      //elem虽然发生了复制，但是复制的是地址，
      //用地址操作对象相当于操作了源对象，跟改了
      //原的对象
      elem.salary+=2000;
  })
  console.log(emps);
  ```

#### map 函数
``` js
arr =[1,2,3,4,5]
var lis= arr.map(function(elem){
    return `<li>${elem}</li>`
})
console.log(arr);
console.log(lis);
```
#### filter函数
``` js
<script>
var arr=[1,2,3,4,5];
var evens=arr.filter(
//先创建空数组等着接符合条件的元素
//var subArr=[]
//filter会拿着回调函数去每个元素上判断一次
  function(elem){
    //只要当前元素是偶数
    return elem%2==0//就放入新数组
  }
//如果当前元素判断结果为true，就追加到新数组
//if(return true) subArr.push(elem)
//遍历结束，返回subArr
)
console.log(arr);
console.log(evens);
</script>
 ```

 #### reduce 函数
 ``` js
 <script>
var class1=[1,3,5,7,9];
var result=class1.reduce(
  function(prev,elem){
    return prev+elem;//将当前值汇总到临时汇总值中
  },
  0//从0开始累加
);
var class2=[2,4,6,8,10];
result=class2.reduce(
  (prev,elem)=>prev+elem,
  result//从上一个班捐的总数继续开始累加
);
console.log(result);//25+30=55
</script>
 ```


 ### let 函数
 ``` js
 function fun(){
  var arr=[];//let将for变为块级作用域之后，
  //for内的变量在for外，不能使用。要想使用，
  //必须定义在for外部。
  //for(var i=0;i<3;i++){
  for(let i=0;i<3;i++){
    arr[i]=function(){console.log(i)}
  //(function(_i){
    //arr[_i]=function(){console.log(_i)}
  //})(i)
  }
  return arr;
}
var funs=fun();
funs[0]();//3  0
funs[1]();//3  1
funs[2]();//3  2
</script>
 ```