### DOM的浏览器兼容性问题
##### 事件绑定
>DOM:3个阶段：
1.外向内：捕获
2.目标触发
3.内向外：冒泡
IE8：2个阶段
没有不火阶段
1.目标阶段
2.内向外：冒泡

**事件绑定**：
DOM:`elem.addEventListener("click",function(){},false)`
>om中默认false；表示默认不捕获事件

IE8:`elem.attachEvent("onclick",function(){})`

**获得事件对象的方法**
DOM：`elem.addEventListener("click",
function(e){e->event})`

IE8中:不会自动传入事件对象e，事件对象保
存在一个全局变量window.event中
``` js
elem.attachEvent("onclick",function(){
    var e=window.event
})
 ```
 兼容所有浏览器的写法
 `e=e||window.event`
**获得目标元素**
DOM：`e.target`
IE8: `E.srcElement`
兼容所有浏览器的写法
`var target=e.target||e.srcElement;`

**阻止冒泡**
DOM：`e.stopPropagation();`
IE8: `e.cancelBubble=true;`
**阻止默认行为**
DOM ：`e.preventDefault();`
IE8:  事件处理函数中 `return false;`
兼容所有浏览器的写法
``` js
 if(typeof e.preventDefault!=="function"){
     // ie8 
     return fales
 }else{
     e.preventDefault();
 }
 ```

**定义一个函数，可以支持所有处理函数的绑定**
``` js
function bindEvent(elem,eventName,
handler){
    if(elem.attachEvent!=="function")
    {
        //DOM
         elem.addEventListener
         (eventName, handle)
    }else{
        //IE8
        elem.attachEvent("on"
        +eventName,function(){
            var e=window.event;
            handler.call(this.e)
        })
    } 
}
bindEvent(btn,"click",function(e){
    this//当前事件冒泡到的父元素
    var target=e.target;//目标元素
})
 ```

 #### w3c中target与currentTarget的区别？
 targer比较专一，后者则随着冒泡改变
 ###### 获得DOM元素的绝对位置
 `elem.offsetLeft`等

 
