###### vur如何去除url中的#
>vue-router默认使用hash模式，路由加载自带#
可以使用router另一种模式history
``` js 
new Router({
    mode:'hostory',
    router:[]
})
 ```
 >当启用history模式时，需要配合后台一起修改，
 不然会出现404，后台不认识没有#的url

 ###### mvc和mvvm的差别
 mvc：手动书写大量的dom操作
 mvvm:model和view绑定，一旦修改自动
 触发通知机制(只能)，无需手动dom操作

 ###### 介绍虚拟Dom树
 虚拟Dom树：仅包含可能变化的节点的可能变化的
 属性的树结构,其他的都不关心,内容精简,体量轻
 ``` html
  <body>
    <div id="app">
        <img src="">
        <h1></h1>
        <h2></h2>
    </div>
  </body>
  ```
  为什么设计这种dom树的存在:内容少，
  便于快速查找
  如何作用:当模型中变量改变时,会通知dom树，
  虚拟dom树缓存本次修改在元素对象上，将一批
  修改的新dom子树和原来的dom树作对比，一旦
  发现不同，就只更新发生变化的dom树

  ##### vue的生命周期
  4个阶段8个钩子函数
  创建:beforCreate();created()(创建完自动
  触发，有data,可发ajax)
  挂载:beforMounte();mounted()(有了dom树)
  更新:beforUpdate();update();
  销毁:befroDestory();distory();

  ##### veu的组件之间通讯
父传给子：:data:"data" props 
子给父
  #### vue-router路由实现
  前端路由：$router为vueRouter实例，想要导航
  到不同的url，则使用$router.push()方法
  hash模式：
  ##### veu的data为啥必须为函数
  每个组件的页面独立区域，数据互不干涉
  让data每个组件return一个新的对象个
  组件专属使用
  ###### computed事件和methods的区别
  >1.computed计算属性是基于他们的依赖进行缓存
  只有相关依赖发生变化时对于 
  >methid,只要发生重新渲染，method总会
  执行该函数
  ##### jquery和vue有什么不同
  jquery专注图层，过多的dom操作
  vue专注于dom层面，减少dom操作
  ##### 自定义指令
  ##### keep-alive的了解
  keep-alive是vue内置的组件，可以使被包含的组件
  保留状态，组件被缓存
  ###### vue中的key 的在作用
  提高查找的效率，提高修改的速度
  ##### active-calss
用在vue-router模块的router-link组件，用exact匹配
##### router的嵌套写法
``` js
routers:[
    {path:"/",component:Home,children:[
        {path:"/",conponent:Details},
        {path:"/details",compinent:Details},
    ]},
    {path:"/login",component:Login},
    {path:"*",component:NotFount}
]

 ```
 ##### 路由之间的跳转
 ``` js
 //1.标签跳转 
 <router-link to=""></router-link>
 // 2.
this.$router.push({  //核心语句
        path:'/select',   //跳转的路径
        query:{           //路由传参时push和query搭配使用 ，作用时传递参数
          id:this.id ,  
        }
      })
  //3、
this.$router.replace{path：‘/’ }
 ```

 #### 懒加载(按需求加载)
 vue首屏加载非常慢；打包应用时，将所有的打包在
 一个文件中，导致js代码非常庞大，严重影响页面
 加载：
 解决:
 1.配置打包工具，将组件分别打包到不同js代码块
 中去
 ``` js
 build/webpack.base.config.js
 output:{
   path:config.build.assersRoot
   filename:'[name].js',
   //新增
   chunkFilename:"[name].js",
   publicPath:process.env.NODE ENV===
   "production"?config.build.assetsPublicPath
   :config.dev.assetsPublicPath
 }
 ```
 2.当路由请求到该组件时，才动态加载组件的内容
 路由字典中，路由配置和以前完全一样但是引入组件
 对象时：
 改为：
 `const Index=()=>inport(@/views/Inddex.vue)`
 当用户在vue中请求当前组件对应的路由地址时，由vue-router
 自动调用加载函数，动态请求Index.vue组件对象

 #### vuex是什么？怎么使用？哪种场景使用它？
 vue是一个全局仓库
 场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入
 购物车
 ##### 自定义指令(v-ckeck,v-focus)的方法有哪些？
 ##### 有哪些钩子函数？有哪些钩子函数参数？
 全局指令:在Vue对象中的directive方法里面有两个参数，一个是
 指令名称，另一个是函数
 组件内定义指令:directives
 钩子函数：bind(绑定事件触发)，inserted(节点插入触发),uppdate
 (组件内相关更新)
 钩子函数:el,binding
 #### 说出4种vue当中的指令和他的用法
 v-if(判断是否隐藏),v-for(把数组遍历出来)
 v-bind(绑定属性);v-model(实现双向绑定)
 #### 双向绑定的原理
 第一步：需要observe的数据对象进行地柜遍历，包括子属性对象的
 属性，都加上setter个getter,这样的话，给对象的某个值赋值
 就会触发setter，继而就能监听到数据变化
 第二步：conpile解析模板指令，将模板中的变量替换数据，然后初始化
 渲染页面视图，并将每个指令对应的节点绑定跟新函数，添加监听
 数据的订阅者，一旦数据变动，收到通知，跟新视图
 第三步：watcher订阅者是Observer和Compile之间的通讯桥梁，主要工作：
 1.在自身实例化属性时，往属性订阅器里添加自己
 2.自身必须有一个update()方法
 3.待属性变动depp notice()通知时，调取自身的update()方法，并触发
 conpile中绑定回调，则功成身退
 第四步：mvvm作为数据绑定的入口，整合了Observer,Compile和Watcher
 三者，通过Observer来监听自己的model数据变化，通过Compile来解析变异模板
 指令，最终利用Watcher和Compile之间的通讯桥梁达到数据变化-->视图交互变化
 -->数据model变更的双向绑定效果

 ##### vuex中有几种属性？
 state;Getters;Mutatons;Sctions;Modules;
 ### getter特性是什么？
 getter可以对state进行计算操作，他就是store色计算属性
 #### vuex的mutation特性死什么
 action类似于muation;不同在于action提交的是mution,二不是直接更改状态
 action可以包含任意一部操作