###### vur如何去除url中的#
>vue-router默认使用hash模式，路由加载自带#
可以使用router另一种模式history
``` js 
new Router({
    mode:'hostory',
    router:[]
})
 ```
 >当启用history模式时，需要配合后台一起修改，
 不然会出现404，后台不认识没有#的url

 ###### mvc和mvvm的差别
 mvc：手动书写大量的dom操作
 mvvm:model和view绑定，一旦修改自动
 触发通知机制(只能)，无需手动dom操作

 ###### 介绍虚拟Dom树
 虚拟Dom树：仅包含可能变化的节点的可能变化的
 属性的树结构,其他的都不关心,内容精简,体量轻
 ``` html
  <body>
    <div id="app">
        <img src="">
        <h1></h1>
        <h2></h2>
    </div>
  </body>
  ```
  为什么设计这种dom树的存在:内容少，
  便于快速查找
  如何作用:当模型中变量改变时,会通知dom树，
  虚拟dom树缓存本次修改在元素对象上，将一批
  修改的新dom子树和原来的dom树作对比，一旦
  发现不同，就只更新发生变化的dom树

  ##### vue的生命周期
  4个阶段8个钩子函数
  创建:beforCreate();created()(创建完自动
  触发，有data,可发ajax)
  挂载:beforMounte();mounted()(有了dom树)
  更新:beforUpdate();update();
  销毁:befroDestory();distory();

  ##### veu的组件之间通讯
父传给子：:data:"data" props 
子给父
  #### vue-router路由实现
  前端路由：$router为vueRouter实例，想要导航
  到不同的url，则使用$router.push()方法
  hash模式：
  ##### veu的data为啥必须为函数
  每个组件的页面独立区域，数据互不干涉
  让data每个组件return一个新的对象个
  组件专属使用
  ###### computed事件和methods的区别
  >1.computed计算属性是基于他们的依赖进行缓存
  只有相关依赖发生变化时对于 
  >methid,只要发生重新渲染，method总会
  执行该函数
  ##### jquery和vue有什么不同
  jquery专注图层，过多的dom操作
  vue专注于dom层面，减少dom操作
  ##### 自定义指令
  ##### keep-alive的了解
  keep-alive是vue内置的组件，可以使被包含的组件
  保留状态，组件被缓存
  ###### vue中的key 的在作用
  提高查找的效率，提高修改的速度
  ##### active-calss
用在vue-router模块的router-link组件，用exact匹配
##### router的嵌套写法
``` js
routers:[
    {path:"/",component:Home,children:[
        {path:"/",conponent:Details},
        {path:"/details",compinent:Details},
    ]},
    {path:"/login",component:Login},
    {path:"*",component:NotFount}
]

 ```